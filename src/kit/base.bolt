from dataclasses import dataclass, field
from typing import ClassVar, NamedTuple

from item:base import base_item
from lib:helpers import id_to_number

ARMOR_SLOTS = ["head", "chest", "legs", "feet"]

class ItemWithCount(NamedTuple):
    item: base_item
    count: int = 1

item_type = base_item | tuple[base_item, int]

@dataclass
class Kit:
    name: str
    tagline: str
    icon: base_item

    armor: dict[str, item_type] = field(default_factory=dict)
    hotbar: list[item_type] = field(default_factory=list)
    offhand: item_type | None = None

    _all_kits: ClassVar[list["Kit"]] = []

    def __post_init__(self):
        self._all_kits.append(self)

        for key in self.armor:
            self.armor[key] = ItemWithCount(self.armor[key])
        
        for index in range(len(self.hotbar)):
            self.hotbar[index] = ItemWithCount(self.hotbar[index])
        
        if self.offhand is not None:
            self.offhand = ItemWithCount(self.offhand)

    @property
    def id(self) -> str:
        return self.name.lower().replace(" ", "_")

    @property
    def numerical_id(self) -> int:
        return id_to_number(self.id)
    
    @property
    def loadout(self) -> str:
        return f"kit:loadout/{self.id}"

    def apply_loadout(self):
        for slot, armor in self.armor.items():
            item replace entity @s f"armor.{slot}" with armor.item armor.count

        for index, hotbar in enumerate(self.hotbar):
            if hotbar.item is not None:
                item replace entity @s f"hotbar.{index}" with hotbar.item hotbar.count
        
        if self.offhand is not None:
            offhand, count = self.offhand
            item replace entity @s weapon.offhand with offhand count


@defer
def generate_kits():
    for kit in Kit._all_kits:
        function kit.loadout:
            kit.apply_loadout()
