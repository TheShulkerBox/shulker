from collections.abc import Iterator
from contextlib import contextmanager
from dataclasses import dataclass

from bolt_expressions import Source


def convert_data_source_into_name(data: DataSource) -> str:
    """Convert a DataSource into a valid name for function/variable names"""
    
    return str(data).replace(" ", "_").replace(".", "_").replace(":", "_")

@dataclass
class loop:
    data: DataSource
    temp_storage: DataSource = STORAGE.temp
    name: str = ""
    reversed: bool = False
    with_index: bool = False

    @dataclass
    class WhileCondition:
        condition: Source

        def __bool__(self):
            if self.condition:
                return False

    def __post_init__(self):
        self.name = self.name or convert_data_source_into_name(self.data)

    def __iter__(self) -> Iterator[DataSource | tuple[int, DataSource]]:
        """Iterate through all elements in a list and yield the element in temp storage

        ```bolt
        for item in loop(some_list):
            if item.value > 1000:
                say big number alert!
        ```
        """

        store result score _loop temp if data var self.data[:]
        execute function ~/loop/{self.name}:
            SCORE.temp["_loop"] -= 1
            STORAGE.macro["index"] = SCORE.temp["_loop"] * -1
            with var STORAGE.macro:
                raw f"$data modify {self.temp_storage.item} set from storage {self.temp_storage._target} data[{{$(index)}}]"

            if self.with_index:
                yield (SCORE.temp["_loop"], self.temp_storage.item)
            else:
                yield self.temp_storage.item
            
            if SCORE.temp["_loop"] > 0:
                function ~/
    
    @contextmanager
    def __loop__(self):
        """Iterate through all elements in a list while a condition is true.

        ```bolt
        while loop(some_list):
            ...
        ```
        
        ⚠️ WARNING: This can create infinite loops if the condition never becomes false.
        """

        execute function ~/loop/while_{self.name}:
            yield self.WhileCondition(self.data)


def storage_path(source: DataSource) -> str:
    return f"{source._target} {source._path}"


def debug_storage(*args):
    output = []
    for arg in args:
        if isinstance(arg, DataSource):
            output.append({storage: arg._target, nbt: str(arg._path)})
        elif isinstance(arg, ScoreSource):
            output.append({score: {name: arg.scoreholder, objective: arg.objective}})
        else:
            output.append(arg)
        output.append(" ")
    
    del output[-1]
    
    return output
