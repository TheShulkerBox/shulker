from component:on_use import OnUse, AnimationLiteral
from component:base import Component
from lib:vector_utils import apply_vector


MAX_PICKUP_DELAY = 32767
BASE_THROW_VECTOR = (0.0, 0.1, 0.3)


class Throwable(Component):
    on_throw: str = ""
    on_tick: str = ""
    power: float = 1.0
    delay: float = 0.5
    cooldown: float = 0.25
    cooldown_group: str = ""
    animation: AnimationLiteral = "spear"
    sound: str = ""

    def render(self):
        append function item_entity_tick:
            if items entity @s contents -self.item function self.on_tick

        self.on_use_callback = f"{self.item.path}/on_throw"

        on_use_component = OnUse(
            callback = self.on_throw,
            delay = self.delay,
            cooldown = self.cooldown,
            animation = self.animation,
            cooldown_group = self.cooldown_group,
            sound = self.sound,

            item = self.item,
            resolved_components = dict(self.resolved_components),
        )
        on_use_component.item = self.item

        return on_use_component.render()

    def post_render(self, resolved_components: dict[str, Any]) -> None:
        function self.on_use_callback:
            init_tag = "item.throwable.on_init"

            anchored eyes run summon item ^ ^ ^.1 {
                Item: {id: "stone", components: {item_model: "air"}},
                Tags: [init_tag],
                PickupDelay: MAX_PICKUP_DELAY,
            }
            as @n[type=item, tag=init_tag] at @s:
                execute summon item_display run function ~/init_display:
                    SELF.merge({
                        item: self.item.as_dict(),
                        Tags: [f"item.{self.item.name}", "component.throwable_display"]
                    })
                    ride @s mount @n[type=item, tag=init_tag]

                SELF.Motion = apply_vector(BASE_THROW_VECTOR)
                SELF.Tags = [f"item.{self.item.name}", "component.throwable_base"]
