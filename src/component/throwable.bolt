from component:on_use import on_use, AnimationLiteral
from lib:vector_utils import apply_vector

from ./base import component

MAX_PICKUP_DELAY = 32767
BASE_THROW_VECTOR = (0.0, 0.1, 0.3)


@component
class throwable:
    on_throw: str = ""
    on_tick: str = ""
    power: float = 1.0
    delay: float = 0.5
    cooldown: float = 0.25
    cooldown_group: str = ""
    animation: AnimationLiteral = "spear"
    sound: str = ""

    def render(self) -> dict[str, Any]:
        append function item_entity_tick:
            if items entity @s contents -self.item function self.on_tick

        self.on_use_callback = f"{self.item.path}/on_throw"

        on_use_component = on_use(
            callback = self.on_throw,
            delay = self.delay,
            cooldown = self.cooldown,
            animation = self.animation,
            cooldown_group = self.cooldown_group,
            sound = self.sound,
        )
        on_use_component.item = self.item

        return on_use_component.render()

    def post_render(self) -> None:
        function self.on_use_callback:
            init_tag = "item.throwable.on_init"

            anchored eyes run summon item ^ ^ ^.1 {
                Item: {id: "stone", components: {item_model: "air"}},
                Tags: [init_tag],
                PickupDelay: MAX_PICKUP_DELAY,
            }
            as @n[type=item, tag=init_tag] at @s:
                execute summon item_display run function ~/init_display:
                    SELF.merge({
                        item: self.item.as_dict(),
                        Tags: [f"item.{self.item.name}", "component.throwable_display"]
                    })
                    ride @s mount @n[type=item, tag=init_tag]

                SELF.Motion = apply_vector(BASE_THROW_VECTOR)
                SELF.Tags = [f"item.{self.item.name}", "component.throwable_base"]
