from typing import Literal, Any
from dataclasses import field

from component:base import component
from item:meta import ItemType
from lib:errors import CustomComponentError
from lib:storage_helpers import storage_path, debug_storage
from lib:helpers import deep_merge_dicts
from server:services/playerdb import PlayerDB


AnimationLiteral = (
    Literal["none"]
    | Literal["eat"]
    | Literal["drink"]
    | Literal["block"]
    | Literal["bow"]
    | Literal["spear"]
    | Literal["spyglass"]
    | Literal["toot_horn"]
    | Literal["brush"]
)


@component
class on_use:
    callback: str
    replace: bool = False
    delay: float = 0.1
    cooldown: float = 0.25
    cooldown_group: str = ""
    animation: AnimationLiteral = "none"
    sound: str = ""
    on_use_effects: list[dict[str, Any]] = field(default_factory=list)

    def render(self) -> dict[str, Any]:
        on_use_path = f"{self.item.path}/on_use"
        advancement on_use_path {
            "criteria": {
                "requirement": {
                    "trigger": "minecraft:consume_item",
                    "conditions": {
                        "item": {
                            "predicates": {
                                "minecraft:custom_data": {"item_id": self.item.name}
                            }
                        }
                    }
                }
            },
            "rewards": {
                "function": on_use_path
            }
        }

        function on_use_path:
            advancement revoke @s only on_use_path
            
            player = PlayerDB.get_self()
            TEMP_STORAGE.self = SELF

            db_item_storage = player.data.item[self.item.name]

            store success score $offhand temp if items entity @s weapon.offhand self.item.conditional_string()

            if TEMP["$offhand"]:
                db_item_storage.on_use.slot = "offhand"
                db_item_storage.on_use.item = TEMP_STORAGE.self.equipment.offhand
            else:
                db_item_storage.on_use.slot = TEMP_STORAGE.self.SelectedItemSlot
                with var db_item_storage.on_use:
                    raw f"$data modify {db_item_storage.on_use.item} set from {TEMP_STORAGE.self.Inventory}[{{Slot: $(slot)b}}]"
            
            
            tag @s add item.on_use_component.return_item
            
            function self.callback

            PlayerDB.save(player)

            if self.replace:
                schedule function ~/return_item 2t replace
                
                function ~/return_item:
                    as @a[tag=item.on_use_component.return_item]:
                        player = PlayerDB.get_self()
                        
                        db_item_storage = player.data.item[self.item.name]
                        
                        item = 19
                        if db_item_storage.on_use.slot == "offhand":
                            with var db_item_storage.on_use.item:
                                if "item_model" in self.resolved_components:
                                    item replace entity @s weapon.offhand with stone[item_model=self.resolved_components["item_model"]]
                                else:
                                    item replace entity @s weapon.offhand with stone
                                $item modify entity @s weapon.offhand {function: 'set_components', components: $(components)}
                        else:
                            with var db_item_storage.on_use.item.components["minecraft:custom_data"]:
                                $data modify storage shulker:temp macro.slot set from storage \
                                    playerdb:temp player.Inventory[{components: {"minecraft:custom_data": {item_id: $(item_id), dynamic_key: $(dynamic_key)}}}]

                            MACRO.components = db_item_storage.on_use.item.components
                            MACRO.id = db_item_storage.on_use.item.id
                            with var MACRO:
                                if "item_model" in self.resolved_components:
                                    val = self.resolved_components["item_model"]
                                    raw f"$item replace entity @s hotbar.$(slot) with stone[item_model={val}]"
                                else:
                                    $item replace entity @s hotbar.$(slot) with $(id)
                                $item modify entity @s hotbar.$(slot) {function: 'set_components', components: $(components)}

        output = {
            "consumable": {
                "consume_seconds": self.delay,
                "animation": self.animation,
                "has_consume_particles": false,
                "sound": {"sound_id": self.sound},
            }
        }

        if self.on_use_effects:
            output["consumable"]["on_consume_effects"] = self.on_use_effects
        
        if self.cooldown:
            output["use_cooldown"] = {"seconds": self.cooldown}

            if self.cooldown_group:
                output["use_cooldown"]["cooldown_group"] = self.cooldown_group
            else:
                output["use_cooldown"]["cooldown_group"] = self.item.name

        if self.replace:
            output["max_stack_size"] = 1

        return output

    def post_render(self) -> None:
        if self.replace:
            self.resolved_components["use_remainder"] = {"id": self.item.id, "components": dict(self.resolved_components)}
