from typing import Literal, Any
from dataclasses import field
from nbtlib.tag import Byte

from component:base import Component
from item:meta import ItemType
from lib:errors import CustomComponentError
from lib:storage_helpers import storage_path, debug_storage
from lib:helpers import deep_merge_dicts
from server:services/playerdb import PlayerDB


AnimationLiteral = (
    Literal["none"]
    | Literal["eat"]
    | Literal["drink"]
    | Literal["block"]
    | Literal["bow"]
    | Literal["spear"]
    | Literal["spyglass"]
    | Literal["toot_horn"]
    | Literal["brush"]
)

# thrown_item_scores: dict[str, ScoreSource] = {}

# def thrown_item_score(item: str):
#     if item not in thrown_item_scores:
#         thrown_item_scores[item] = Scoreboard(f"thrown_item_{item}", criteria=f"minecraft.dropped:minecraft.{item}")
    
#     return thrown_item_scores[item]


class OnUse(Component):
    callback: str
    replace: bool = False
    delay: float = 0.1
    cooldown: float = 0.25
    cooldown_group: str = ""
    animation: AnimationLiteral = "none"
    sound: str = ""
    on_use_effects: list[dict[str, Any]] = field(default_factory=list)

    def render(self) -> dict[str, Any]:
        on_use_path = f"{self.item.path}/on_use"
        advancement on_use_path {
            "criteria": {
                "requirement": {
                    "trigger": "minecraft:consume_item",
                    "conditions": {
                        "item": {
                            "predicates": {
                                "minecraft:custom_data": {"item_id": self.item.name}
                            }
                        }
                    }
                }
            },
            "rewards": {
                "function": on_use_path
            }
        }

        function on_use_path:
            advancement revoke @s only on_use_path
            
            if self.replace:
                # mainhand items get used over offhand so we check that first
                unless items entity @s weapon.mainhand self.item.conditional_string():
                    STORAGE.macro.item = SELF.equipment.offhand
                    STORAGE.macro.item.slot = "offhand"

                if items entity @s weapon.mainhand self.item.conditional_string():
                    STORAGE.macro.item = SELF.SelectedItem
                    STORAGE.macro.item.slot = "mainhand"
                
            function self.callback

            if self.replace:
                execute function ~/return_item with var STORAGE.macro.item:
                    $item modify entity @s weapon.$(slot) {function: 'set_components', components: $(components)}

        output = {
            "consumable": {
                "consume_seconds": self.delay,
                "animation": self.animation,
                "has_consume_particles": false,
                "sound": {"sound_id": self.sound},
            }
        }

        if self.on_use_effects:
            output["consumable"]["on_consume_effects"] = self.on_use_effects
        
        if self.cooldown:
            output["use_cooldown"] = {"seconds": self.cooldown}

            if self.cooldown_group:
                output["use_cooldown"]["cooldown_group"] = self.cooldown_group
            else:
                output["use_cooldown"]["cooldown_group"] = self.item.name

        if self.replace:
            output["max_stack_size"] = 1
        
        return output

    def post_render(self, resolved_components: dict[str, Any]) -> None:
        if self.replace:
            resolved_components["use_remainder"] = {"id": self.item.id, "components": dict(resolved_components)}
