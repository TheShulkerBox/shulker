from typing import Literal, Any
from dataclasses import field
from nbtlib.tag import Byte

from component:base import Component
from item:meta import ItemType
from lib:errors import CustomComponentError
from lib:storage_helpers import storage_path, debug_storage
from lib:helpers import deep_merge_dicts
from server:services/playerdb import PlayerDB
from server:core import root_advancement


AnimationLiteral = (
    Literal["none"]
    | Literal["eat"]
    | Literal["drink"]
    | Literal["block"]
    | Literal["bow"]
    | Literal["trident"]
    | Literal["spyglass"]
    | Literal["toot_horn"]
    | Literal["brush"]
    | Literal["spear"]
)

# thrown_item_scores: dict[str, ScoreSource] = {}

# def thrown_item_score(item: str):
#     if item not in thrown_item_scores:
#         thrown_item_scores[item] = Scoreboard(f"thrown_item_{item}", criteria=f"minecraft.dropped:minecraft.{item}")
    
#     return thrown_item_scores[item]


class OnUse(Component):
    callback: str
    replace: bool = False
    delay: float = 0.1
    cooldown: float = 0.25
    cooldown_group: str = ""
    animation: AnimationLiteral = "none"
    sound: str = ""
    on_use_effects: list[dict[str, Any]] = field(default_factory=list)

    def render(self) -> dict[str, Any]:
        """Using consume_item adv, replace item with same components on use."""
        
        on_use_path = f"{self.item.path}/on_use"
        advancement on_use_path {
            "parent": root_advancement,
            "criteria": {
                "requirement": {
                    "trigger": "minecraft:consume_item",
                    "conditions": {
                        "item": {
                            "predicates": {
                                "minecraft:custom_data": {"item_id": self.item.name}
                            }
                        }
                    }
                }
            },
            "rewards": {
                "function": on_use_path
            }
        }

        function on_use_path:
            advancement revoke @s only on_use_path
            
            # if replacing, cache data based on slot
            if self.replace:
                # mainhand items get used over offhand so we check that first
                unless items entity @s weapon.mainhand self.item.conditional_string():
                    STORAGE.temp.item = SELF.equipment.offhand
                    STORAGE.temp.item.slot = "offhand"

                if items entity @s weapon.mainhand self.item.conditional_string():
                    STORAGE.temp.item = SELF.SelectedItem
                    STORAGE.temp.item.slot = "mainhand"
                
            function self.callback

            # return item by macroing it back onto the item
            # we need to flicker the item by replacing it with a blank item w/ an id
            if self.replace:
                execute function ~/return_item with var STORAGE.temp.item:
                    $item replace entity @s weapon.$(slot) with $(id)
                    $item modify entity @s weapon.$(slot) {function: 'set_components', components: $(components)}
        
        # setup base component
        output = {
            "consumable": {
                "consume_seconds": self.delay,
                "animation": self.animation,
                "has_consume_particles": false,
                "sound": {"sound_id": self.sound},
            }
        }

        # add conditional stuff based on arguments
        if self.on_use_effects:
            output["consumable"]["on_consume_effects"] = self.on_use_effects
        
        if self.cooldown:
            output["use_cooldown"] = {"seconds": self.cooldown}

            if self.cooldown_group:
                output["use_cooldown"]["cooldown_group"] = self.cooldown_group
            else:
                output["use_cooldown"]["cooldown_group"] = self.item.name

        if self.replace:
            output["max_stack_size"] = 1
        
        return output

    def post_render(self, resolved_components: dict[str, Any]) -> None:
        """After completing all components rendering, fill in use_remainder with the final components"""

        if self.replace:
            resolved_components["use_remainder"] = {"id": self.item.id, "components": dict(resolved_components)}
