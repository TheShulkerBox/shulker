import component:on_use as _
from component:on_hold import on_using_timer
from item:base import Item
from lib:motion import apply_motion_vector


class Dart(Item):
    id = "arrow"
    item_model = "stone"
    item_name = "taco sauce 2 deluxe"
    on_use = {callback: ~/on_use, replace: true, cooldown: 0.1}


function ~/on_use:
    apply_motion_vector([0.0, 1.5, 2.0])


class PoisonDart(Item):
    id = "arrow"
    item_model = "poisonous_potato"
    item_name = "poison taco sauce 3 deluxe"
    on_use = {callback: ~/on_use_poison, replace: true, cooldown: 0.5}


function ~/on_use_poison:
    STORAGE.temp.vector = [0] * 3
    for i in range(3):
        store result storage shulker:temp vector[i] double 0.01 random value -500..500
    apply_motion_vector(STORAGE.temp.vector)


class Potato(Item):
    id = "stone"
    item_model = "potato"
    item_name = "Bouncing Betty"
    max_damage = 101
    on_hold = {tick_callback: ~/potato/tick, release_callback: ~/potato/release}
    use_effects = {can_sprint: true, speed_multiplier: 0.7}
    max_stack_size = 1


function ~/potato/tick:
    STORAGE.macro = {damage: max(0, 100 - (2 * on_using_timer["@s"]))}
    unless items entity @s weapon.mainhand Potato.conditional_string():
        with var STORAGE.macro:
            $item modify entity @s weapon.offhand {function: "set_components", components: {damage: $(damage)}}

    if items entity @s weapon.mainhand Potato.conditional_string():
        with var STORAGE.macro:
            $item modify entity @s weapon.mainhand {function: "set_components", components: {damage: $(damage)}}

function ~/potato/release:
    say surprise!
