"""
This file manages the game instance system.

A game instance represents the lifecycle of any game (pre-game, starting, in-progress, ending, etc.)
It gets created the moment a game is being configured (joining a duels arena, players sitting in the
box, etc.) Each instance gets attached an id that can be used to identify related data such as
state or status. This data can sit in either scoreboards, tags, or storage.

The instance metadata will sit in storage which handles the management of itself. Then, games can
register new data via scoreboards that can be indexed via macro-ing fakeplayers or objectives,
tags with macro'd names, or storage with macro'd indexing (via `Database`, etc).

While the main box selection of games will be limited to 1 instance at a time, games such as
duels will allow multiple instancing. This system will be designed to support both cases.

Players will also be assigned to the INSTANCE_ID scoreboard to keep track of what instance they
are currently in.
"""

from contextlib import contextmanager

from lib:db import Database
from server:core import SERVER_LOAD, SERVER_TICK

from ./models import Map, GAME_META
from ./events import ON_LEAVE_GAME

INSTANCE_META = Database(GAME_META.active_instances)
INSTANCE_ID = Scoreboard("game.instance_id", criteria="dummy")

SAME_INSTANCE_TAG = "game.in_same_instance"


append function SERVER_LOAD:
    if not INSTANCE_ID["#latest"] >= 0:
        INSTANCE_ID["#latest"] = 0


append function ON_LEAVE_GAME:
    INSTANCE_ID["@s"].reset()


def new_instance(map: Map) -> ScoreSource:
    """Attempts to add a new instance.
    
    First checks if a map is currently being instanced.
    Adds the map if not, otherwise return an -1.
    """
    # We store the result of whether we find an instance or not in a temp scoreboard.
    # This makes it easy to return it at runtime.
    if INSTANCE_META.get(map_id=map.id) != false:
        SCORE.temp["#output"] = -1
    else:
        INSTANCE_ID["#latest"] += 1
        INSTANCE_META.append(
            {
                id: INSTANCE_ID["#latest"],
                gamemode: map.gamemode,
                map_id: map.id,
            }
        )
        SCORE.temp["#output"] = INSTANCE_ID["#latest"]
    
    return SCORE.temp["#output"]


def new_instance_unsafe(map: Map) -> ScoreSource:
    """Adds a new instance without checking for existing instances."""
    INSTANCE_ID["#latest"] += 1
    INSTANCE_META.append(
        {
            id: INSTANCE_ID["#latest"],
            gamemode: map.gamemode,
            map_id: map.id,
        }
    )
    return INSTANCE_ID["#latest"]


def remove_instance(instance_id: int | ScoreSource | DataSource) -> DataSource:
    """Attempts to remove a new instance."""
    return INSTANCE_META.pop(id=instance_id)


@contextmanager
def select_instance_players(instance_id: int | ScoreSource | DataSource) -> str:
    """Selects players in the same instance and adds a tag (auto-removes).
    
    ```bolt
    # assume instance_id is a scoreboard or storage value of an instance.
    with select_instance_players(instance_id) as instance_tag:
        say @a[tag=instance_tag]
    ```
    ->
    ```mcfunction
    scoreboard players operation #instance_id temp = @s game.instance_id
    execute
        as @a[scores={game.instance_id=1..}]
        if score @s game.instance_id = #instance_id temp
        run tag @s add game.in_same_instance
    
    say @a[tag=game.in_same_instance]

    tag @a remove game.in_same_instance
    ```
    """
    SCORE.temp["#instance_id"] = instance_id
    execute
        as @a[scores={INSTANCE_ID=1..}]
        if score var INSTANCE_ID["@s"] = var SCORE.temp["#instance_id"]
        run tag @s add SAME_INSTANCE_TAG
    
    yield SAME_INSTANCE_TAG

    tag @a remove SAME_INSTANCE_TAG



append function SERVER_TICK:
    execute function ./instance_tick:
        for instance in INSTANCE_META.loop(name=~/loop):
            with select_instance_players(instance.id) as instance_tag:
                # if we find no one, kill the instance and skip the rest of this loop
                execute unless entity @a[tag=instance_tag] run return:
                    remove_instance(instance.id)
