from lib:storage_helpers import loop
from server:core import SERVER_LOAD, SERVER_TICK
from server:admin import error_debug
from player:events import ON_DEATH
from lib:utils import matching

from ../player import TEAM_SCORE
from ../events import ON_LEAVE_GAME
from ../instance import INSTANCE_META, INSTANCE_ID, SAME_INSTANCE_TAG, remove_instance, select_instance_players
from ./models import DuelsMap


GAME_TIMER = Scoreboard("duels.GAME_TIMER")
BELOW_NAME_DISPLAY = Scoreboard("duels.below_name_display")
KILLS = Scoreboard("duels.team_kills")
DEATHS = Scoreboard("duels.team_deaths")

TEAM_1 = "duels.team_1"
TEAM_2 = "duels.team_2"
PREGAME_MARKER = "duels.pregame_marker"


append function SERVER_LOAD:
    team add TEAM_1 "Duels Team 1"
    team add TEAM_2 "Duels Team 2"
    
    for team in [TEAM_1, TEAM_2]:
        team modify team friendlyFire false
        team modify team prefix "ðŸ—¡ "


append function SERVER_TICK:
    """We loop through each live duels instance so we can process each one individually."""

    duels_instances = INSTANCE_META.get(gamemode="duels")

    # loop through each duels instance
    for instance in loop(duels_instances):
        SCORE.temp["#current_instance_id"] = instance.id

        # temporarily tag everyone in the same instance (during the loop)
        with select_instance_players(instance.id) as instance_tag:
            # if we find no one, kill the instance and skip the rest of this loop
            execute unless entity @a[tag=SAME_INSTANCE_TAG] run return:
                remove_instance(SCORE.temp["#current_instance_id"])
            
            # get the cooresponding map
            instance_map = DuelsMap.get(id=instance.map_id)
            if instance_map == false:
                # if this fails, tell an admin
                error_debug("Map not found from instance: ", instance)

            # count the players in the instance
            execute store result score var SCORE.temp["#instance_player_count"] if entity @a[tag=SAME_INSTANCE_TAG]
            if SCORE.temp["#instance_player_count"] >= instance_map.max_player_count:
                instance_map.instance_id = instance.id  # we copy this over so that it's useable in the macro
                function ./start_game with var instance_map
    
    # copy team (TODO: change?)
    TEAM_SCORE[f"@a[team={TEAM_1}]"] = 1
    TEAM_SCORE[f"@a[team={TEAM_2}]"] = 2


append function ON_LEAVE_GAME:
    """Ensure we clean up the duel scores and tags of a player leaving a game"""


function ./start_game:
    """Starts a dueling match (tping lobby players to the arena)
    
    macro arguments from `DuelsMap` ($(name), $(id), etc.) + $(instance_id)
    """
    # make players join separate teams
    team join TEAM_1 @r[tag=SAME_INSTANCE_TAG]
    team join TEAM_2 @r[tag=SAME_INSTANCE_TAG, team=!TEAM_1]

    # teleport to spawns
    tp @a[tag=SAME_INSTANCE_TAG, team=TEAM_1] $(spawn_1)
    tp @a[tag=SAME_INSTANCE_TAG, team=TEAM_2] $(spawn_2)

    execute as @a[tag=SAME_INSTANCE_TAG] at @s:
        # look at opponent
        tp @s ~ ~ ~ facing entity @p[tag=SAME_INSTANCE_TAG, distance=3..]

        # lock in place via spectator spam + marker
        gamemode spectator
        summon marker ~ ~ ~ {Tags: [PREGAME_MARKER]}
        spectate @n[type=marker, tag=PREGAME_MARKER] @s

        # set below name
        scoreboard players display name @s BELOW_NAME_DISPLAY ""

    GAME_TIMER[f"@a[tag={SAME_INSTANCE_TAG}]"] = 80
    KILLS[f"@a[tag={SAME_INSTANCE_TAG}]"] = 0
    DEATHS[f"@a[tag={SAME_INSTANCE_TAG}]"] = 0
    schedule function ./pregame 1t replace


function ./pregame:
    execute as @a[scores={GAME_TIMER=1..}] at @s function ~/per_player:
        schedule function ./pregame 1t replace

        # lock player in place
        spectate @n[type=marker, tag=PREGAME_MARKER] @s

        # generate the xp ping sounds + title
        for i in range(3, 0, -1):
            timer_score = (i + 1) * 20
            playsound minecraft:entity.experience_orb.pickup master @s[scores={GAME_TIMER=timer_score}] ~ ~ ~ 1 1
            title @s[scores={GAME_TIMER=timer_score}] title {text: str(i)}

        # fight!
        if GAME_TIMER["@s"] == 0:
            playsound minecraft:entity.experience_orb.pickup master @s[scores={GAME_TIMER=0}] ~ ~ ~ 1 2
            title @s[scores={GAME_TIMER=0}] title ""
            title @s[scores={GAME_TIMER=0}] subtitle {text: "Fight!"}
            gamemode adventure @s
            kill @n[type=marker, tag=PREGAME_MARKER]


append function ON_DEATH:
    with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
        # increment team score
        pred = matching(TEAM_SCORE, TEAM_SCORE["@s"])  # helps filter @a for score that matches TEAM_SCORE["@s"]
        scoreboard players add var KILLS[f"@a[tag=instance_tag, predicate={pred}]"] 1
        
        # check if we exceeded 3 kills
        execute if score var KILLS[f"@a[tag=instance_tag, predicate={pred}, limit=1]"] matches 3.. return:
            STORAGE.macro = {
                winning_team: TEAM_SCORE[f"@a[tag=instance_tag, predicate={pred}, limit=1]"],
                losing_team: TEAM_SCORE["@s"],
            }
            function ./end_game with var STORAGE.macro
        
        # Display the `x-y` (my kills - opponent kills)
        title @a[tag=instance_tag] title ""
        execute
            as @a[tag=instance_tag]
            at @s
            run title @s subtitle [
                KILLS["@s"],
                "-",
                KILLS[f"@p[distance=3.., tag={instance_tag}]"]  # look for nearest player that's not u
            ]


function ./end_game:
    GAME_TIMER[f"@a[tag={instance_tag}]"] = -1
    title @a[tag=instance_tag, scores={TEAM_SCORE=$(winning_team)}] title "Match Won"
    title @a[tag=instance_tag, scores={TEAM_SCORE=$(losing_team)}] title "Match Lost"
    execute
        as @a[tag=instance_tag]
        at @s
        run title @s subtitle [
            KILLS["@s"],
            "-",
            KILLS[f"@p[distance=3.., tag={instance_tag}]"]
        ]
