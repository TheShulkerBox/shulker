from lib:storage_helpers import loop
from server:core import SERVER_LOAD, SERVER_TICK
from server:admin import error_debug
from player:events import ON_DEATH
from lib:utils import matching
from lib:player import tag_self

from ../player import TEAM_SCORE
from ../events import ON_LEAVE_GAME
from ../instance import INSTANCE_META, INSTANCE_ID, remove_instance, select_instance_players
from ./models import DuelsMap

# We reuse the same timer for 2 timers with an offset
# This has an added benefit of ensuring that only 1 exact timer will be running at the same time.
GAME_TIMER = Scoreboard("duels.game_timer", criteria="dummy")
DURING_DEATH_TIMER = Scoreboard("duels.during_death_timer", criteria="dummy")
PREGAME_COUNTDOWN = 80
# POSTGAME_COUNTDOWN = 80
DEATH_COUNTDOWN = 90

BELOW_NAME_DISPLAY = Scoreboard("duels.below_name_display", criteria="dummy")
KILLS = Scoreboard("duels.team_kills", criteria="dummy")
HEALTH = Scoreboard("duels.health", criteria="health")
START_GAME_TRIGGER = Scoreboard("start_match", criteria="trigger")

TEAM_1 = "duels.team_1"
TEAM_2 = "duels.team_2"
PREGAME_MARKER = "duels.pregame_marker"

TEAM_MATCHER = matching(TEAM_SCORE, TEAM_SCORE["@s"])


append function SERVER_LOAD:
    team add TEAM_1 "Duels Team 1"
    team add TEAM_2 "Duels Team 2"
    
    for team in [TEAM_1, TEAM_2]:
        team modify team friendlyFire false
        team modify team prefix "ðŸ—¡ "
        team modify team seeFriendlyInvisibles false


append function SERVER_TICK:
    execute function ./tick_instance:
        START_GAME_TRIGGER["@a"].enable()
        execute as @a[scores={START_GAME_TRIGGER=1..}] run function ~/attempt_start_game:
            START_GAME_TRIGGER["@s"].reset()
            if INSTANCE_ID["@s"] < 0:
                return run tellraw @s {text: "You are not dueling right now!", color: Theme.Failure}

            instance = INSTANCE_META.get(id=INSTANCE_ID["@s"])
            instance_map = DuelsMap.get(id=instance.map_id)
            if instance_map == false:
                tellraw @s {text: "You are not in a valid duel instance!", color: Theme.Failure}
            
            with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
                execute store result score var SCORE.temp["#player_count"] if entity @a[tag=instance_tag]
                execute if score var SCORE.temp["#player_count"] matches ..1 return:
                    tellraw @s {text: "You need at least 2 players to start the duel!", color: Theme.Failure}

                execute function ./start_game with var instance_map:
                    # make players join separate teams
                    team join TEAM_1 @r[tag=instance_tag]
                    team join TEAM_2 @r[tag=instance_tag, team=!TEAM_1]
                    
                    # copy team (TODO: change?)
                    TEAM_SCORE[f"@a[team={TEAM_1}]"] = 1
                    TEAM_SCORE[f"@a[team={TEAM_2}]"] = 2

                    # teleport to spawns
                    tp @a[tag=instance_tag, team=TEAM_1] $(spawn_1)
                    tp @a[tag=instance_tag, team=TEAM_2] $(spawn_2)

                    execute as @a[tag=instance_tag] at @s function ~/per_player with var instance_map:
                        # setup spawnpoint
                        spawnpoint @s ~ ~ ~ ~ ~
                        gamemode spectator @s
                        
                        # rotate and ride pregame marker
                        summon item_display ~ ~1 ~ {Tags: [PREGAME_MARKER]}
                        rotate @n[type=item_display, tag=PREGAME_MARKER] facing entity @p[tag=instance_tag, predicate=!TEAM_MATCHER()]
                        ride @s mount @n[type=item_display, tag=PREGAME_MARKER]
                        $rotate @s[scores={game.team=1}] facing $(spawn_2)
                        $rotate @s[scores={game.team=2}] facing $(spawn_1)

                        # set below name
                        scoreboard players display name @s BELOW_NAME_DISPLAY ""

                    GAME_TIMER[f"@a[tag={instance_tag}]"] = PREGAME_COUNTDOWN
                    KILLS[f"@a[tag={instance_tag}]"] = 0
                    schedule function ./pregame 1t replace
        

def display_score_subtitle(instance_tag: str):
    """Utility in displaying the score (x-y)."""
    execute as @a[tag=instance_tag]:
        title @s subtitle [
            KILLS["@s"],
            " - ",
            # TODO handle spectators in same instance_tag
            KILLS[f"@a[tag={instance_tag}, predicate=!{TEAM_MATCHER()}, limit=1]"]
        ]


function ./pregame:
    execute as @a[scores={GAME_TIMER=(1, PREGAME_COUNTDOWN)}] at @s function ~/per_player:
        schedule function ./pregame 1t replace
        GAME_TIMER["@s"] -= 1

        # lock player in place (free-cam)
        ride @s mount @n[type=item_display, tag=PREGAME_MARKER]

        # generate the xp ping sounds + title
        if GAME_TIMER["@s"] == 60:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 1
            title @s title {text: "3"}

        if GAME_TIMER["@s"] == 40:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 1
            title @s title {text: "2"}
            
        if GAME_TIMER["@s"] == 20:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 1
            title @s title {text: "1"}

        # fight!
        if GAME_TIMER["@s"] == 0:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 2
            title @s title ""
            title @s subtitle {text: "Fight!"}
            gamemode adventure @s
            kill @n[type=item_display, tag=PREGAME_MARKER]


append function ON_DEATH:
    execute unless score var DURING_DEATH_TIMER["@s"] matches 1.. run function ./on_death:
        with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
            # game is considered tied if everyone has no health!
            unless entity @a[tag=instance_tag, scores={HEALTH=1..}] return:
                title @a[tag=instance_tag] title {text: "Tie Round", color: "gray"}
                display_score_subtitle(instance_tag)
                GAME_TIMER["@s"] = DEATH_COUNTDOWN
                schedule function ./during_death 1t replace

            # increment team score
            scoreboard players add var KILLS[f"@a[tag={instance_tag}, predicate=!{TEAM_MATCHER()}]"] 1

            # check if we exceeded 3 kills (short-circuit here if so)
            execute as @a[tag=instance_tag, scores={KILLS=3..}, limit=1] return run function ./end_game:
                # GAME_TIMER[f"@a[tag={instance_tag}]"] = POSTGAME_COUNTDOWN
                title @a[tag=instance_tag, predicate=TEAM_MATCHER()] title "Match Won"
                title @a[tag=instance_tag, predicate=!TEAM_MATCHER()] title "Match Lost"
                display_score_subtitle(instance_tag)
                execute as @a[tag=instance_tag] run trigger leave_game
            
            # Display the `x-y` (my kills - opponent kills)
            title @a[tag=instance_tag] title ""
            display_score_subtitle(instance_tag)
            
            # during death timer
            DURING_DEATH_TIMER["@s"] = DEATH_COUNTDOWN
            tellraw @a[tag=instance_tag] ["opponent healths: ", HEALTH[f"@a[tag={instance_tag}, predicate=!{TEAM_MATCHER()}]"]]

            gamemode spectator @s
            effect give @a[tag=instance_tag, predicate=!TEAM_MATCHER()] minecraft:instant_health infinite 0 true
            effect give @a[tag=instance_tag, predicate=!TEAM_MATCHER()] minecraft:resistance infinite 0 true

            schedule function ./during_death 1t replace

    
function ./during_death:
    execute as @a[scores={DURING_DEATH_TIMER=(1, DEATH_COUNTDOWN)}] at @s function ~/per_player:
        schedule function ./during_death 1t replace
        DURING_DEATH_TIMER["@s"] -= 1
        
        with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
            # ensure that spectator doesn't go too far
            execute if entity @s[gamemode=spectator]:
                with tag_self() as self_tag:
                    execute at @p[tag=!self_tag, tag=instance_tag, distance=30..] run tp @s ~ ~ ~
            
                # visibility
                particle minecraft:crit ~ ~ ~ 0 0 0 0.2 5 force
        
            # respawn
            if DURING_DEATH_TIMER["@s"] == 0:
                execute function ./respawn:
                    gamemode adventure @s
                    DURING_DEATH_TIMER[f"@a[tag={instance_tag}]"].reset()
                    kill @a[tag=instance_tag]


append function ON_LEAVE_GAME:
    """Ensure we clean up the duel scores and tags of a player leaving a game"""
    GAME_TIMER["@s"].reset()
    BELOW_NAME_DISPLAY["@s"].reset()
    KILLS["@s"].reset()
    TEAM_SCORE["@s"].reset()
    DURING_DEATH_TIMER["@s"].reset()
