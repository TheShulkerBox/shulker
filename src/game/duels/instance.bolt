from lib:storage_helpers import loop
from server:core import SERVER_LOAD, SERVER_TICK
from server:events import ON_JOIN
from server:events/on_server_leave import ON_SERVER_LEAVE, PLAYER_WHO_LEFT
from server:admin import error_debug
from player:events import ON_DEATH, DEATH_SCORE
from lib:utils import matching
from lib:player import tag_self

from ../player import TEAM_SCORE
from ../events import ON_LEAVE_GAME
from ../instance import INSTANCE_META, INSTANCE_ID, remove_instance, select_instance_players
from ../models import Gamemode
from ./models import DuelsMap

GAME_TIMER = Scoreboard("duels.game_timer", criteria="dummy")
DURING_DEATH_TIMER = Scoreboard("duels.during_death_timer", criteria="dummy")
PREGAME_COUNTDOWN = 80
# POSTGAME_COUNTDOWN = 80
DEATH_COUNTDOWN = 90

BELOW_NAME_DISPLAY = Scoreboard("duels.below_name_display", criteria="dummy")
KILLS = Scoreboard("duels.team_kills", criteria="dummy")
HEALTH = Scoreboard("duels.health", criteria="health")
START_GAME_TRIGGER = Scoreboard("start_match", criteria="trigger")

TEAM_1 = "duels.team_1"
TEAM_2 = "duels.team_2"
PREGAME_MARKER = "duels.pregame_marker"

TEAM_MATCHER = matching(TEAM_SCORE, TEAM_SCORE["@s"])


def leave_duels():
    """Call when duels is done for a player."""
    INSTANCE_ID['@s'].reset()
    trigger leave_game


append function SERVER_LOAD:
    execute function ./load:
        team add TEAM_1 "Duels Team 1"
        team add TEAM_2 "Duels Team 2"
        
        for team in [TEAM_1, TEAM_2]:
            team modify team friendlyFire false
            team modify team prefix "ðŸ—¡ "
            team modify team seeFriendlyInvisibles false


append function SERVER_TICK:
    execute function ./tick_instance:
        # TODO: swap start game trigger w/ kit selection
        START_GAME_TRIGGER["@a"].enable()
        execute as @a[scores={START_GAME_TRIGGER=1..}] run function ~/attempt_start_game:
            START_GAME_TRIGGER["@s"].reset()

            if not (INSTANCE_ID["@s"] >= 1):
                return run tellraw @s {text: "You are not dueling right now!", color: Theme.Failure}

            instance = INSTANCE_META.get(id=INSTANCE_ID["@s"])
            instance_map = DuelsMap.get(id=instance.map_id)
            if instance_map == false:
                return run tellraw @s {text: "You are not in a valid duel instance!", color: Theme.Failure}
            
            with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
                # condition: start only if we have at least 2 players
                execute store result score var SCORE.temp["#player_count"] if entity @a[tag=instance_tag]
                execute if score var SCORE.temp["#player_count"] matches ..1 return:
                    tellraw @s {text: "You need at least 2 players to start the duel!", color: Theme.Failure}

                execute function ./start_game with var instance_map:
                    # make players join separate teams
                    team join TEAM_1 @r[tag=instance_tag]
                    team join TEAM_2 @r[tag=instance_tag, team=!TEAM_1]
                    
                    # copy team (TODO: change?)
                    TEAM_SCORE[f"@a[team={TEAM_1}]"] = 1
                    TEAM_SCORE[f"@a[team={TEAM_2}]"] = 2

                    # teleport to spawns
                    tp @a[tag=instance_tag, team=TEAM_1] $(spawn_1)
                    tp @a[tag=instance_tag, team=TEAM_2] $(spawn_2)

                    execute as @a[tag=instance_tag] at @s function ~/per_player with var instance_map:
                        # setup spawnpoint
                        spawnpoint @s ~ ~ ~ ~ ~
                        gamemode spectator @s
                        
                        # rotate and ride pregame marker
                        summon item_display ~ ~1 ~ {Tags: [PREGAME_MARKER]}
                        ride @s mount @n[type=item_display, tag=PREGAME_MARKER]
                        $rotate @s[scores={game.team=1}] facing $(spawn_2)
                        $rotate @s[scores={game.team=2}] facing $(spawn_1)

                        # set below name
                        scoreboard players display name @s BELOW_NAME_DISPLAY ""

                    GAME_TIMER[f"@a[tag={instance_tag}]"] = PREGAME_COUNTDOWN
                    KILLS[f"@a[tag={instance_tag}]"] = 0
                    schedule function ./pregame 1t replace
        

def display_score_subtitle(instance_tag: str):
    """Utility in displaying the score (x-y)."""
    execute as @a[tag=instance_tag]:
        title @s subtitle [
            KILLS["@s"],
            " - ",
            KILLS[f"@a[tag={instance_tag}, predicate=!{TEAM_MATCHER()}, limit=1]"]
        ]


function ./pregame:
    execute as @a[scores={GAME_TIMER=(1, PREGAME_COUNTDOWN)}] at @s function ~/per_player:
        schedule function ./pregame 1t replace
        GAME_TIMER["@s"] -= 1

        # lock player in place (free-cam)
        ride @s mount @n[type=item_display, tag=PREGAME_MARKER]

        # generate the xp ping sounds + title
        if GAME_TIMER["@s"] == 60:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 1
            title @s title {text: "3"}

        if GAME_TIMER["@s"] == 40:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 1
            title @s title {text: "2"}
            
        if GAME_TIMER["@s"] == 20:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 1
            title @s title {text: "1"}

        # fight!
        if GAME_TIMER["@s"] == 0:
            playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 1 2
            title @s title ""
            title @s subtitle {text: "Fight!"}
            gamemode adventure @s
            kill @n[type=item_display, tag=PREGAME_MARKER]


prepend function ON_DEATH:
    execute unless score var DURING_DEATH_TIMER["@s"] matches 1.. run function ./on_death:
        with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
            # game is considered tied if everybody is dead!
            execute store result score var SCORE.temp["#player_count"] if entity @a[tag=instance_tag]
            execute store result score var SCORE.temp["#dead_count"] if entity @a[tag=instance_tag, scores={DEATH_SCORE=1..}]
            tellraw @a ["player count: ", SCORE.temp["#player_count"], ", dead count: ", SCORE.temp["#dead_count"]]
            if SCORE.temp["#player_count"] == SCORE.temp["#dead_count"]:
                return run function ./tie_match:
                    tellraw @a {text: "The duel has ended in a tie!", color: Theme.Body}
                    title @a[tag=instance_tag] title {text: "Tie Round", color: "gray"}
                    display_score_subtitle(instance_tag)
                    DURING_DEATH_TIMER[f"@a[tag={instance_tag}]"] = DEATH_COUNTDOWN
                    gamemode spectator @a[tag=instance_tag]
                    schedule function ./during_death 1t replace

            # increment team score
            scoreboard players add var KILLS[f"@a[tag={instance_tag}, predicate=!{TEAM_MATCHER()}]"] 1

            # check if we exceeded 3 kills (short-circuit here if so) TODO: hardcoded
            execute as @a[tag=instance_tag, scores={KILLS=3..}, limit=1] return run function ./end_game:
                # GAME_TIMER[f"@a[tag={instance_tag}]"] = POSTGAME_COUNTDOWN
                title @a[tag=instance_tag, predicate=TEAM_MATCHER()] title "Match Won"
                title @a[tag=instance_tag, predicate=!TEAM_MATCHER()] title "Match Lost"
                display_score_subtitle(instance_tag)
                execute as @a[tag=instance_tag]:
                    leave_duels()
            
            # Display the `x-y` (my kills - opponent kills)
            title @a[tag=instance_tag] title ""
            display_score_subtitle(instance_tag)
            
            # during death timer
            DURING_DEATH_TIMER["@s"] = DEATH_COUNTDOWN
            tellraw @a[tag=instance_tag] ["opponent healths: ", HEALTH[f"@a[tag={instance_tag}, predicate=!{TEAM_MATCHER()}]"]]

            gamemode spectator @s
            effect give @a[tag=instance_tag, predicate=!TEAM_MATCHER()] minecraft:instant_health infinite 0 true
            effect give @a[tag=instance_tag, predicate=!TEAM_MATCHER()] minecraft:resistance infinite 0 true

            schedule function ./during_death 1t replace

    
function ./during_death:
    execute as @a[scores={DURING_DEATH_TIMER=(1, DEATH_COUNTDOWN)}] at @s function ~/per_player:
        schedule function ./during_death 1t replace
        DURING_DEATH_TIMER["@s"] -= 1
        
        with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
            # ensure that spectator doesn't go too far
            execute if entity @s[gamemode=spectator]:
                with tag_self() as self_tag:
                    execute at @p[tag=!self_tag, tag=instance_tag, distance=30..] run tp @s ~ ~ ~
            
                # visibility
                particle minecraft:crit ~ ~ ~ 0 0 0 0.2 5 force
        
            # respawn
            if DURING_DEATH_TIMER["@s"] == 0:
                execute function ./respawn:
                    gamemode adventure @a[tag=instance_tag]
                    DURING_DEATH_TIMER[f"@a[tag={instance_tag}]"].reset()
                    kill @a[tag=instance_tag]
                    DEATH_SCORE[f"@a[tag={instance_tag}]"].reset()


#> Handle forfeits
# both /trigger leave_game AND server leave

def handle_opponent_of_forfeiter(tellraw_message: str):
    tellraw @s {text: tellraw_message, color: Theme.Body}
    title @s title "Match Won Uncontested"
    leave_duels()


prepend function ON_LEAVE_GAME:
    """Ensure we clean up the duel scores and tags of a player leaving a game"""
    if INSTANCE_ID["@s"] > 0:
        instance = INSTANCE_META.get(id=INSTANCE_ID["@s"])
        if instance.gamemode == Gamemode.Duels:
            execute function ./forfeit_match:
                tellraw @s {text: "You have forfeited the duel!", color: Theme.Failure}
                title @s title "Match Forfeited"
                with select_instance_players(INSTANCE_ID["@s"]) as instance_tag:
                    display_score_subtitle(instance_tag)
                    execute as @a[tag=instance_tag, predicate=!TEAM_MATCHER()]:
                        handle_opponent_of_forfeiter("Your opponent has forfeited the duel by leaving the match!")

    GAME_TIMER["@s"].reset()
    BELOW_NAME_DISPLAY["@s"].reset()
    KILLS["@s"].reset()
    TEAM_SCORE["@s"].reset()
    DURING_DEATH_TIMER["@s"].reset()


# TODO ON_SERVER_LEAVE queue to display message to people who leave
append function ON_SERVER_LEAVE:
    # Copy data from person who left into some temp vars before we reset them
    raw f"$scoreboard players operation {SCORE.temp['#instance_id']} = $(name) {INSTANCE_ID}"
    raw f"$scoreboard players operation {SCORE.temp['#team_score']} = $(name) {TEAM_SCORE}"
    raw f"$scoreboard players operation {SCORE.temp['#kills']} = $(name) {KILLS}"
    raw f"$scoreboard players reset $(name) {INSTANCE_ID}"
    
    # if player is in an active instance
    if SCORE.temp['#instance_id'] >= 1:
        instance = INSTANCE_META.get(id=SCORE.temp['#instance_id'])

        # if they are playing duels, forfeit match
        if instance.gamemode == Gamemode.Duels:
            execute function ./forfeit_match/on_leave_game:
                # select other duels players
                with select_instance_players(SCORE.temp['#instance_id']) as instance_tag:
                    # match them based on team and say your opponent has forfeited
                    # TODO: what to do if someone on your team forfeits
                    team_matcher = matching(TEAM_SCORE, SCORE.temp['#team_score'])
                    execute as @a[tag=instance_tag, predicate=!team_matcher()]:
                        title @s subtitle [KILLS["@s"], " - ", SCORE.temp['#kills']]
                        handle_opponent_of_forfeiter("Your opponent has forfeited the duel by leaving the server!")
