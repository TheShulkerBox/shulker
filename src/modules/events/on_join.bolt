"""
Handles joins via the `leave_game` criteria. We also have to handle
server crashes which doesn't set that variable. We use the trick where
`/reload` also occurs on server start to help handle that edge case.
"""

from lib:db import UUID1, UUID2, UUID3, UUID4, PlayerDB

# Iff score is :
#  <not set> -> player has not joined (server crashed / on reload)
#  0 -> player has joined / is online
#  1 -> player has not joined (player has left game)
on_join = Scoreboard("player.on_join", criteria="minecraft.custom:minecraft.leave_game")

append function sys:load:
    """We reset all scores and set online players to 0 on load"""

    on_join["*"].reset()
    on_join["@a"] = 0


append function sys:tick:
    """Detect player joining on two conditions:
    
    1. If `on_join` score increments, that means they left the game
    2. If `on_join` score doesn't exist, that means we've reloaded (occurs on server crash too!)
    """

    as @a unless score var on_join["@s"] = var on_join["@s"]:
        on_join["@s"] += 1
    
    as @a[scores={on_join=1..}] at @s function event:on_join
        

append function event:on_join:
    """Called when a player joins (even if the server had crashed).

    as/at @s: player
    """

    on_join["@s"] = 0

    execute function ~/welcome_message:
        title @s title {text: "Welcome back", color: theme.primary, bold: true}
        title @s subtitle {text: "The Shulker Box", color: theme.secondary, bold: true}

        as @a[tag=staff] at @s playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 2 1.5
        playsound block.end_portal_frame.fill master @s 0 65 0 2 0.5 1

    execute function ~/check_uuids:
        execute store result score uuid1 temp run data get entity @s UUID[0]
        execute store result score uuid2 temp run data get entity @s UUID[1]
        execute store result score uuid3 temp run data get entity @s UUID[2]
        execute store result score uuid4 temp run data get entity @s UUID[3]

        if (
            (TEMP["uuid1"] == UUID1["@s"])
            and (TEMP["uuid2"] == UUID2["@s"])
            and (TEMP["uuid3"] == UUID3["@s"])
            and (TEMP["uuid4"] == UUID4["@s"])
        ):
            return 1

        # at this point, we have either a new player or a player that has changed their UUID
        UUID1["@s"] = TEMP["uuid1"]
        UUID2["@s"] = TEMP["uuid2"]
        UUID3["@s"] = TEMP["uuid3"]
        UUID4["@s"] = TEMP["uuid4"]

        # PlayerDB.get_player(TEMP["player"])
