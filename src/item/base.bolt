from lib:shulker_box import SHULKER_BOX_COORDS, SHULKER_BOX, SHULKER_DROP_CONTENTS
from server:core import server_tick, server_load

from ./meta import ItemType

dynamic_key = Scoreboard("item.dynamic_key", criteria="dummy")
item_storage = Data.storage("item:meta")

ItemType.ctx = ctx


class Item(metaclass=ItemType):
    """Item is the base class for all items in the data pack. This is a special behaving structure that
    barely resembles a class leveraging metaclasses.
    
    The basic structure is to define all components as "class variables" and then use custom methods
    to define special behavior to simplify component construction. This allows you to abstract
    complex behavior as isolated "custom components" or "component transformers" that can be reused
    across multiple items.

    ```
    class basic_item(item):
        id = "minecraft:stone"
        item_name = {text: "Basic Item", color: theme.primary}
        lore = ["This is a basic item.", "It does nothing special."]
    ```
    This item just uses vanilla components to define a stone item with a custom name and lore.

    ```
    class CustomItem(Item):
        id = "minecraft:custom_item"
        item_name = {text: "Custom Item", color: theme.primary}
        lore = ["This is a custom item.", "It has special behavior."]
        test_component = false

        def test_component(val: bool):
            return {"enchantment_glint_override": val}
    ```
    Here, we define a basic `test_component` that converts a `bool` into a new set of vanilla components.

    ```
    class CustomItem2(Item):
        id = "minecraft:custom_item_2"
        item_name = {text: "Custom Item 2", color: theme.primary}
        lore = ["This is another custom item.", "It has special behavior."]
        dyed_color = "#ff0000"
    ```
    This item uses a `dyed_color` transformer that is automatically transformed into a color integer. Note, the
    implementation for this transformer is defined in the `item` class itself, so you can use it in any item.

    Custom components are functions that **must** end with "_component" and define a new component that gets converted
    into one or more components. This is useful for defining a simple interface for coordinating multiple components.
    Custom components can even define their own functions and other resource files in order to achieve it's purpose.

    Component transformers on the other hand are functions that **must** end with "_transformer" and are used to transform
    an existing component's value into a new value. If the transformer returns `None`, no action is taken. This is useful
    when providing multiple input types for a component, such as a color that can be either a string or an integer.
    """

    id = "paper"
    count = 1
    tool = {"can_destroy_blocks_in_creative": False, "rules": []}

    @classmethod
    def build(self):
        # append function server_load:
        #     execute function f"item:load/{self.name}":
        #         STORAGE.temp.item = {components: self.components}
        #         STORAGE.macro.name = self.name
        #         with var STORAGE.macro:
        #             $data modify storage item:meta item.$(name) set from storage shulker:temp item
        
        function f"item:give/{self.name}":
            SHULKER_BOX.Items = [{id: self.id, components: self.components}]
            dynamic_key[self.name] += 1
            SHULKER_BOX.Items[0].components."minecraft:custom_data".dynamic_key = dynamic_key[self.name]
            if SHULKER_BOX.Items[0].components."minecraft:use_remainder":  # stupid hack
                SHULKER_BOX.Items[0].components."minecraft:use_remainder".components."minecraft:custom_data".dynamic_key = dynamic_key[self.name]
            loot give @s mine SHULKER_BOX_COORDS SHULKER_DROP_CONTENTS


# Yes, this deletes the above item in storage but that's ok
append function server_load:
    item_storage.item = {}
