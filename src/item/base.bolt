from itertools import chain

from lib:shulker_box import SHULKER_BOX_COORDS, SHULKER_BOX, SHULKER_DROP_CONTENTS
from server:core import SERVER_TICK, SERVER_LOAD
# from component:dynamic_key import DynamicKey

from ./type import ItemType

item_storage = Data.storage("item:meta")

ItemType.ctx = ctx


class Item(metaclass=ItemType):
    """Item is the base class for all items in the data pack. This is a special behaving structure that
    barely resembles a class leveraging metaclasses.
    
    The basic structure is to define all components as "class variables" and then use custom methods
    to define special behavior to simplify component construction. This allows you to abstract
    complex behavior as isolated "custom components" or "component transformers" that can be reused
    across multiple items.

    ```
    class basic_item(item):
        id = "minecraft:stone"
        item_name = {text: "Basic Item", color: theme.primary}
        lore = ["This is a basic item.", "It does nothing special."]
    ```
    This item just uses vanilla components to define a stone item with a custom name and lore.

    ```
    class CustomItem(Item):
        id = "minecraft:custom_item"
        item_name = {text: "Custom Item", color: theme.primary}
        lore = ["This is a custom item.", "It has special behavior."]
        test_component = false

        def test_component(val: bool):
            return {"enchantment_glint_override": val}
    ```
    Here, we define a basic `test_component` that converts a `bool` into a new set of vanilla components.

    ```
    class CustomItem2(Item):
        id = "minecraft:custom_item_2"
        item_name = {text: "Custom Item 2", color: theme.primary}
        lore = ["This is another custom item.", "It has special behavior."]
        dyed_color = "#ff0000"
    ```
    This item uses a `dyed_color` transformer that is automatically transformed into a color integer. Note, the
    implementation for this transformer is defined in the `item` class itself, so you can use it in any item.

    Custom components are functions that **must** end with "_component" and define a new component that gets converted
    into one or more components. This is useful for defining a simple interface for coordinating multiple components.
    Custom components can even define their own functions and other resource files in order to achieve it's purpose.

    Component transformers on the other hand are functions that **must** end with "_transformer" and are used to transform
    an existing component's value into a new value. If the transformer returns `None`, no action is taken. This is useful
    when providing multiple input types for a component, such as a color that can be either a string or an integer.
    """

    id = "paper"
    count = 1
    tool = {"can_destroy_blocks_in_creative": False, "rules": []}

    @classmethod
    def prepare(self):
        """Prepare the item for runtime data injection by inserting it in a Shulker Box.
        
        Assumes:
        - Caller prepares the Shulker Box (resets and manages)
        - Caller gives or sends the item to a player or location
        - The Shulker Box will not be full
        
        The item prepared will be in the last slot (accessible via -1)
        """
        SHULKER_BOX.Items.append({id: self.id, components: self.components})
        
        # render the components
        for component_or_transformer in chain(self.custom_components.values(), self.custom_transformers.values()):
            component_or_transformer.render(SHULKER_BOX.Items[-1])

    @classmethod
    def build(self):
        function f"item:give/{self.name}":
            SHULKER_BOX.Items = []
            self.prepare()
            loot give @s mine SHULKER_BOX_COORDS SHULKER_DROP_CONTENTS


# Yes, this deletes the above item in storage but that's ok
append function SERVER_LOAD:
    item_storage.item = {}
