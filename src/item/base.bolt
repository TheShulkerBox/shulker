from component:base import custom_components, custom_transformers
from lib:shulker_box import SHULKER_BOX_COORDS, SHULKER_BOX
from server:core import server_tick

from ./meta import ItemType

dynamic_key = Scoreboard("item.dynamic_key", criteria="dummy")
item_entity_tick = ~/entity_tick
item_ticking_tag = "item.ticking"

ItemType.ctx = ctx

class base_item(metaclass=ItemType):
    """item is the base class for all items in the data pack. This is a special behaving structure that
    barely resembles a class leveraging metaclasses.

    The basic structure is to define all components as "class variables" and then use custom methods
    to define special behavior to simplify component construction. This allows you to abstract
    complex behavior as isolated "custom components" or "component transformers" that can be reused
    across multiple items.

    ```
    class basic_item(item):
        id = "minecraft:stone"
        item_name = {text: "Basic Item", color: theme.primary}
        lore = ["This is a basic item.", "It does nothing special."]
    ```
    This item just uses vanilla components to define a stone item with a custom name and lore.

    ```
    class custom_item(item):
        id = "minecraft:custom_item"
        item_name = {text: "Custom Item", color: theme.primary}
        lore = ["This is a custom item.", "It has special behavior."]
        test_component = false

        def test_component(val: bool):
            return {"enchantment_glint_override": val}
    ```
    Here, we define a basic `test_component` that converts a `bool` into a new set of vanilla components.

    ```
    class custom_item_2(item):
        id = "minecraft:custom_item_2"
        item_name = {text: "Custom Item 2", color: theme.primary}
        lore = ["This is another custom item.", "It has special behavior."]
        dyed_color = "#ff0000"
    ```
    This item uses a `dyed_color` transformer that is automatically transformed into a color integer. Note, the
    implementation for this transformer is defined in the `item` class itself, so you can use it in any item.

    Custom components are functions that **must** end with "_component" and define a new component that gets converted
    into one or more components. This is useful for defining a simple interface for coordinating multiple components.
    Custom components can even define their own functions and other resource files in order to achieve it's purpose.

    Component transformers on the other hand are functions that **must** end with "_transformer" and are used to transform
    an existing component's value into a new value. If the transformer returns `None`, no action is taken. This is useful
    when providing multiple input types for a component, such as a color that can be either a string or an integer.
    """

    id = None
    count = 1
    tool = {"can_destroy_blocks_in_creative": False, "rules": []}

    _custom_components = custom_components
    _custom_transformers = custom_transformers

    @classmethod
    def build(self):
        function f"item:{self.name}/give":
            MACRO.components = self.components
            dynamic_key[self.name] += 1
            MACRO.components.custom_data.dynamic_key = dynamic_key[self.name]
            item replace block SHULKER_BOX_COORDS container.0 with self.id
            positioned SHULKER_BOX_COORDS with var MACRO:
                $item modify block ~ ~ ~ container.0 {"function": "set_components", "components": $(components)}


append function server_tick:
    as @e[type=item, tag=item_ticking_tag] at @s function item_entity_tick
