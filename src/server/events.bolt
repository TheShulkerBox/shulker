from lib:db import UUID1, UUID2, UUID3, UUID4, PlayerDB
from lib:utils import get_player_name


#> Events
on_first_join = ~/on_first_join
on_join = ~/on_join
# on_player_count = 


# Iff score is :
#  <not set> -> player has not joined (server crashed / on reload)
#  0 -> player has joined / is online
#  1 -> player has not joined (player has left game)
on_join_score = Scoreboard("player.on_join", criteria="minecraft.custom:minecraft.leave_game")

time_played = Scoreboard("stats.time_played", criteria="minecraft.custom:minecraft.play_time")


append function server_tick:
    # First join based on time played scoreboard
    as @a[scores={time_played=..1}] at @s function ./on_first_join

    # Detect player joining on two conditions:
    # 
    # 1. If `on_join` score increments, that means they left the game
    # 2. If `on_join` score doesn't exist, that means we've reloaded (occurs on server crash too!)
    as @a unless score var on_join_score["@s"] = var on_join_score["@s"]:
        on_join_score["@s"] += 1
    
    as @a[scores={on_join_score=1..}] at @s function ./on_join


append function server_load:
    """We reset all scores and set online players to 0 on load"""

    on_join_score["*"].reset()
    on_join_score["@a"] = 0


append function on_first_join:
    """
    This detects first join based on the `time_played` stat scoreboard. We use a scoreboard
    instead of an advancement because it's easier to reset when testing `on_first_join` logic.
    """

    playsound minecraft:ui.toast.challenge_complete master @s ~ ~ ~ 0.7 0.8 0.7


append function on_join:
    """Called when a player joins (even if the server had crashed).

    as/at @s: player
    """

    on_join_score["@s"] = 0

    execute function ~/welcome_message:
        title @s title {text: "Welcome back", color: theme.primary, bold: true}
        title @s subtitle {text: "The Shulker Box", color: theme.secondary, bold: true}

        as @a[tag=staff] at @s playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 2 1.5
        playsound block.end_portal_frame.fill master @s 0 65 0 2 0.5 1

    execute function ~/check_uuids:
        # 1. check whether our UUID matches our scoreboard UUIDs
        store result score uuid1 temp run data get entity @s UUID[0]
        store result score uuid2 temp run data get entity @s UUID[1]
        store result score uuid3 temp run data get entity @s UUID[2]
        store result score uuid4 temp run data get entity @s UUID[3]

        # if so, we are *that* guy
        if (
            (TEMP["uuid1"] == UUID1["@s"])
            and (TEMP["uuid2"] == UUID2["@s"])
            and (TEMP["uuid3"] == UUID3["@s"])
            and (TEMP["uuid4"] == UUID4["@s"])
        ):
            return 1

        # 2. otherwise, we have 3 situations:
        #    a. player is new, so we add them to the database
        #    b. player is old, but they changed their name to a new one with no scores
        #    c. player is old, but they changed their name to one that used to exist
        # First we set their UUIDs to the scoreboard
        UUID1["@s"] = TEMP["uuid1"]
        UUID2["@s"] = TEMP["uuid2"]
        UUID3["@s"] = TEMP["uuid3"]
        UUID4["@s"] = TEMP["uuid4"]

        # If we exist in the database, then we are ok!
        if function PlayerDB.exists_self():
            execute return 1

        # Else, we are a new player
        TEMP_STORAGE.player = {}
        function ~/../on_playerdb_init
        PlayerDB.add_player(TEMP_STORAGE.player)
        return 1
